From a565d401f81a7300abfd14d809c7a93d45a4087e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=C3=98yvind=20Netland?= <oyvind@netland.name>
Date: Sat, 17 Dec 2016 23:48:40 +0100
Subject: [PATCH] adds Beaglebone GPIO and PWM RTDM drivers

---
 drivers/xenomai/beaglebone/Kconfig  |  16 ++
 drivers/xenomai/beaglebone/Makefile |   7 +
 drivers/xenomai/beaglebone/bbgpio.c | 513 ++++++++++++++++++++++++++++++++++++
 drivers/xenomai/beaglebone/bbgpio.h |  36 +++
 drivers/xenomai/beaglebone/bbpwm.c  | 332 +++++++++++++++++++++++
 drivers/xenomai/beaglebone/bbpwm.h  |  34 +++
 6 files changed, 938 insertions(+)
 create mode 100644 drivers/xenomai/beaglebone/Kconfig
 create mode 100644 drivers/xenomai/beaglebone/Makefile
 create mode 100755 drivers/xenomai/beaglebone/bbgpio.c
 create mode 100644 drivers/xenomai/beaglebone/bbgpio.h
 create mode 100755 drivers/xenomai/beaglebone/bbpwm.c
 create mode 100644 drivers/xenomai/beaglebone/bbpwm.h

diff --git a/drivers/xenomai/beaglebone/Kconfig b/drivers/xenomai/beaglebone/Kconfig
new file mode 100644
index 0000000..5ac44d0
--- /dev/null
+++ b/drivers/xenomai/beaglebone/Kconfig
@@ -0,0 +1,16 @@
+menu "Beaglebone RTDM I/O"
+visible if ARM
+
+config XENO_BB_GPIO
+	tristate "Beaglebone GPIO RTDM driver"
+	help
+
+	A RTDM-based driver for using Beaglebone GPIO.
+
+config XENO_BB_PWM
+	tristate "Beaglebone PWM RTDM driver"
+	help
+
+	A RTDM-based driver for using Beaglebone PWM.
+
+endmenu
diff --git a/drivers/xenomai/beaglebone/Makefile b/drivers/xenomai/beaglebone/Makefile
new file mode 100644
index 0000000..034c353
--- /dev/null
+++ b/drivers/xenomai/beaglebone/Makefile
@@ -0,0 +1,7 @@
+ccflags-y += -Ikernel
+
+obj-$(CONFIG_XENO_BB_GPIO) += xeno_bbgpio.o
+obj-$(CONFIG_XENO_BB_PWM) += xeno_bbpwm.o
+
+xeno_bbgpio-y := bbgpio.o
+xeno_bbpwm-y := bbpwm.o
diff --git a/drivers/xenomai/beaglebone/bbgpio.c b/drivers/xenomai/beaglebone/bbgpio.c
new file mode 100755
index 0000000..772f69d
--- /dev/null
+++ b/drivers/xenomai/beaglebone/bbgpio.c
@@ -0,0 +1,513 @@
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/pwm.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+#include <rtdm/rtdm.h>
+#include <rtdm/driver.h>
+
+#include "bbgpio.h"
+
+//! struct with data representing a GPIO device.
+struct bbgpio_data {
+    //! the direction of the GPIO
+    int dir;
+    //! the the edge the GPIO IRQ will trigger on
+    int edge;
+    //! the GPIO channel number
+    int gpio_n;
+    //! how long a read function will wait for an IRQ
+    nanosecs_rel_t timeout;
+    //! the RTDM IRQ channel
+    rtdm_irq_t irq;
+    //! the RTDM event used by IRQ handler to signal any waiting tasks
+    rtdm_event_t irq_event;
+};
+
+/*!
+ * Method for handling an open action. Depending on the oflags, the GPIO
+ * will be opened as an input, output or input IRQ.
+ * @param fd rtdm file descriptor pointer
+ * @param oflags the value given when opening the file
+ * @return 0 on success, otherwise an error code
+ */
+static int bbgpio_open(struct rtdm_fd *fd, int oflags);
+/*!
+ * Method for handling a read action. For input GPIO the current
+ * GPIO value is returned. IRQ GPIO will block until an interrupt
+ * occurs or a timeout. GPIO output channels return error.
+ * @param fd rtdm file descriptor pointer
+ * @param buf user space read buffer
+ * @param size size of user read buffer
+ * @return 0 on success, otherwise an error code
+ */
+static ssize_t bbgpio_read_rt(struct rtdm_fd *fd, void __user *buf, size_t size);
+/*!
+ * Method for handling a write action. For output GPIO the value provided
+ * is set on the GPIO output. GPIO input and IRQ GPIO channels return error.
+ * @param fd rtdm file descriptor pointer
+ * @param buf user space write buffer
+ * @param size size of user write buffer
+ * @return 0 on success, otherwise an error code
+ */
+static ssize_t bbgpio_write_rt(struct rtdm_fd *fd, const void __user *buf, size_t size);
+/*!
+ * Method for handling a ioctl action.
+ * DIR GET return the direction of all GPIO channels.
+ * EDGE GET return the edge of IRQ GPIO channels, otherwise error.
+ * EDGE SET set the edge of IRQ GPIO channels, otherwise error.
+ * TIMEOUT GET return the timeout of IRQ GPIO channels, otherwise error.
+ * TIMEOUT SET set the timeout of IRQ GPIO channels, otherwise error.
+ * @param fd rtdm file descriptor pointer
+ * @param request the ioctl request code
+ * @param arg pointer to input or output data
+ * @return 0 on success, otherwise an error code
+ */
+static int bbgpio_ioctl_rt(struct rtdm_fd *fd, unsigned int request, void *arg);
+/*!
+ * Method for handling a close action, which will disable the GPIO device.
+ * @param fd rtdm file descriptor pointer
+ */
+static void bbgpio_close(struct rtdm_fd *fd);
+/*!
+ * IRQ handler, will trigger an event, which wake up waiting read methods.
+ * @param irq the RTDM IRQ channel
+ * @return always 1
+ */
+static int bbgpio_irq_f(rtdm_irq_t *irq);
+/*!
+ * Initialize a GPIO channel of the given number. Does not activate the GPIO.
+ * @param n GPIO number (in the list of this driver)
+ * @return 0 on success, otherwise an error code
+ */ 
+static int bbgpio_device_init(int n);
+/*
+ * Exit a GPIO channel of a given number.
+ * @param n GPIO number (in the list of this driver)
+ */
+static void bbgpio_device_exit(int n);
+
+
+//! initialization of GPIO data struct array, with all GPIO that can be used
+//! without changing the mux settings
+static struct bbgpio_data _bbgpio_data[] = {
+    {.gpio_n = 20},
+    {.gpio_n = 26},
+    {.gpio_n = 27},
+    {.gpio_n = 44},
+    {.gpio_n = 45},
+    {.gpio_n = 46},
+    {.gpio_n = 47},
+    {.gpio_n = 48},
+    {.gpio_n = 60},
+    {.gpio_n = 61},
+    {.gpio_n = 65},
+    {.gpio_n = 66},
+    {.gpio_n = 67},
+    {.gpio_n = 68},
+    {.gpio_n = 69},
+    {.gpio_n = 112},
+    {.gpio_n = 115},
+    {.gpio_n = 117},
+};
+
+//! the driver for the Beaglebone GPIO RTDM driver
+static struct rtdm_driver _bbgpio_driver = {
+    .profile_info = RTDM_PROFILE_INFO("bbgpio", RTDM_CLASS_EXPERIMENTAL,
+            RTDM_SUBCLASS_GENERIC, 42),
+    .device_flags = RTDM_NAMED_DEVICE | RTDM_EXCLUSIVE,
+    .device_count = ARRAY_SIZE(_bbgpio_data),
+    .context_size = sizeof(struct bbgpio_data),
+    .ops = {
+        .open = bbgpio_open,
+        .read_rt = bbgpio_read_rt,
+        .write_rt = bbgpio_write_rt,
+        .ioctl_rt = bbgpio_ioctl_rt,
+        .close = bbgpio_close,
+    },
+};
+
+//! initialization of GPIO device struct array, with all GPIO that can be used
+//! without changing the mux settings with name indicating pin position
+static struct rtdm_device _bbgpio_devices[] = {
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio20_P9_41",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio26_P8_14",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio27_P8_17",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio44_P8_12",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio45_P8_11",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio46_P8_16",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio47_P8_15",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio48_P9_15",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio60_P9_12",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio61_P8_26",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio65_P8_18",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio66_P8_07",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio67_P8_08",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio68_P8_10",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio69_P8_09",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio112_P9_13",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio115_P9_27",
+    },
+    {
+        .driver = &_bbgpio_driver,
+        .label = "gpio117_P9_27",
+    },
+};
+
+static int bbgpio_open(struct rtdm_fd *fd, int oflags)
+{
+    int ret = 0;
+    int irq_n;
+    struct rtdm_dev_context *context;
+    struct bbgpio_data *data;
+
+    context = rtdm_fd_to_context(fd);
+    data = (struct bbgpio_data*)context->device->device_data;
+
+    data->dir = oflags;
+    data->edge = 0;
+
+    switch (data->dir) {
+    case BBGPIO_DIR_IN:
+        // request input GPIO
+        ret = gpio_request_one(data->gpio_n, GPIOF_DIR_IN, THIS_MODULE->name);
+        if (ret < 0) {
+            goto rollback_request;
+        }
+
+        break;
+
+    case BBGPIO_DIR_OUT:
+        // request output GPIO
+        ret = gpio_request_one(data->gpio_n, GPIOF_DIR_OUT, THIS_MODULE->name);
+        if (ret < 0) {
+            goto rollback_request;
+        }
+
+        break;
+
+    case BBGPIO_DIR_IRQ:
+        irq_n = gpio_to_irq(data->gpio_n);
+
+        // request GPIO IRQ
+        ret = gpio_request_one(data->gpio_n, GPIOF_DIR_IN, THIS_MODULE->name);
+        if (ret < 0) {
+            goto rollback_request;
+        }
+
+        // set trigger on both edges as default
+        data->edge = BBGPIO_IOCTL_EDGE_BOTH;
+        ret = irq_set_irq_type(irq_n, IRQ_TYPE_EDGE_BOTH);
+        if (ret < 0) {
+            goto rollback_irq;
+        }
+
+        // request IRQ
+        ret = rtdm_irq_request(&data->irq, irq_n, bbgpio_irq_f,
+                0, THIS_MODULE->name, (void*)data);
+        if (ret < 0) {
+            goto rollback_irq;
+        }
+
+        // enable IRQ
+        ret = rtdm_irq_enable(&data->irq);
+        if (ret < 0) {
+            goto rollback_irq_enable;
+        }
+
+        // initialize the event that will be used to signal waiting read methods.
+        rtdm_event_init(&data->irq_event, 0);
+
+        break;
+
+    default:
+        return -EPERM;
+    }
+
+    return 0; /* success */
+
+rollback_irq_enable:
+    rtdm_irq_free(&data->irq);
+rollback_irq:
+    gpio_free(data->gpio_n);
+rollback_request:
+    return ret;
+}
+
+static ssize_t bbgpio_read_rt(struct rtdm_fd *fd, void __user *buf, size_t size) {
+    s16 ret;
+    struct rtdm_dev_context *context;
+    struct bbgpio_data *data;
+
+    context = rtdm_fd_to_context(fd);
+    data = (struct bbgpio_data*)context->device->device_data;
+
+    switch (data->dir) {
+    case BBGPIO_DIR_IRQ:
+        // wait for an interrupt
+        rtdm_event_timedwait(&(data->irq_event), data->timeout, NULL);
+   
+    case BBGPIO_DIR_IN:
+        // read GPIO value and return to user space
+        // is performed for both input and IRQ
+        if (gpio_get_value(data->gpio_n) == 1) {
+            ret = rtdm_safe_copy_to_user(fd, buf, "1", 2);
+        } else {
+            ret = rtdm_safe_copy_to_user(fd, buf, "0", 2);
+        }
+
+        if (ret <= 0) {
+            return ret;
+        }
+        return 2;
+    
+    default:
+        return -EPERM;
+    }
+}
+
+static ssize_t bbgpio_write_rt(struct rtdm_fd *fd, const void __user *buf, size_t size)
+{
+    s16 ret;
+    u8 buf2[100];
+    struct rtdm_dev_context *context;
+    struct bbgpio_data *data;
+
+    context = rtdm_fd_to_context(fd);
+    data = (struct bbgpio_data*)context->device->device_data;
+
+    switch (data->dir) {
+    case BBGPIO_DIR_OUT:
+        // read from user space and set new GPIO output value
+        ret = rtdm_safe_copy_from_user(fd, buf2, buf, size);
+        if (ret < 0) {
+            return ret;
+        }
+        buf2[size] = 0;
+
+        if (buf2[0] == '0') {
+            gpio_set_value(data->gpio_n, 0);
+        } else {
+            gpio_set_value(data->gpio_n, 1);
+        }
+
+        return size;
+    
+    default:
+        return -EPERM;
+    }
+}
+
+static int bbgpio_ioctl_rt(struct rtdm_fd *fd, unsigned int request, void *arg)
+{
+    s16 ret;
+    int tmp;
+    struct rtdm_dev_context *context;
+    struct bbgpio_data *data;
+
+    context = rtdm_fd_to_context(fd);
+    data = (struct bbgpio_data*)context->device->device_data;
+
+    switch (request) {
+    case BBGPIO_IOCTL_DIR_GET:
+        // return the direction of the GPIO channel
+        return rtdm_safe_copy_to_user(fd, arg, &(data->dir), sizeof(data->dir));
+
+    case BBGPIO_IOCTL_EDGE_GET:
+        if (data->dir != BBGPIO_DIR_IRQ) {
+            return -EPERM;
+        }
+        // if channel is IRQ, return its current edge
+        return rtdm_safe_copy_to_user(fd, arg, &(data->edge), sizeof(data->edge));
+
+    case BBGPIO_IOCTL_EDGE_SET:
+        if (data->dir != BBGPIO_DIR_IRQ) {
+            return -EPERM;
+        }
+
+        // if channel is IRQ, set the edge that trigger interrupt
+        ret = rtdm_safe_copy_from_user(fd, &tmp, arg, sizeof(int));
+        if (ret) {
+            return ret;
+        }
+
+        data->edge = tmp;
+        switch (data->edge) {
+        case BBGPIO_IOCTL_EDGE_RISING:
+            return irq_set_irq_type(gpio_to_irq(data->gpio_n), IRQ_TYPE_EDGE_RISING);
+        case BBGPIO_IOCTL_EDGE_FALLING:
+            return irq_set_irq_type(gpio_to_irq(data->gpio_n), IRQ_TYPE_EDGE_FALLING);
+        case BBGPIO_IOCTL_EDGE_BOTH:
+            return irq_set_irq_type(gpio_to_irq(data->gpio_n), IRQ_TYPE_EDGE_BOTH);
+        default:
+            return -EINVAL;
+        }
+
+    case BBGPIO_IOCTL_TIMEOUT_GET:
+        if (data->dir != BBGPIO_DIR_IRQ) {
+            return -EPERM;
+        }
+        // if channel is IRQ, return its current interrupt timeout
+        return rtdm_safe_copy_to_user(fd, arg, &data->timeout, sizeof(data->timeout));
+
+    case BBGPIO_IOCTL_TIMEOUT_SET:
+        if (data->dir != BBGPIO_DIR_IRQ) {
+            return -EPERM;
+        }
+
+        // if channel is IRQ, set the interrupt timeout
+        ret = rtdm_safe_copy_from_user(fd, &data->timeout, arg, sizeof(data->timeout));
+        if (ret < sizeof(data->timeout)) {
+            return ret;
+        }
+
+        if (data->dir == BBGPIO_DIR_IRQ) {
+            data->timeout = tmp;
+            return 0;
+        } else {
+            return -EINVAL;
+        }
+
+    default:
+        return -ENOTTY;
+    }
+}
+
+static void bbgpio_close(struct rtdm_fd *fd)
+{
+    struct rtdm_dev_context *context;
+    struct bbgpio_data *data;
+
+    // free GPIO 
+    context = rtdm_fd_to_context(fd);
+    data = (struct bbgpio_data*)context->device->device_data;
+
+    if (data->dir == BBGPIO_DIR_IRQ) {
+        rtdm_irq_free(&data->irq);
+    }
+
+    gpio_free(data->gpio_n);
+}
+
+static int bbgpio_irq_f(rtdm_irq_t *irq)
+{
+    struct bbgpio_data *data =  rtdm_irq_get_arg(irq, struct bbgpio_data);
+
+    // wake up any read methods that are waiting for the interrupt
+    rtdm_event_pulse(&data->irq_event);
+    return 1;
+}
+
+
+static int bbgpio_device_init(int n)
+{
+    int ret;
+
+    // register the RTDM device
+    _bbgpio_devices[n].device_data = &_bbgpio_data[n];
+    ret = rtdm_dev_register(&_bbgpio_devices[n]);
+    if (ret < 0) {
+        rtdm_printk(KERN_ERR "BBGPIO ERROR initialize %i\n", n);
+        goto rollback_dev_register;
+    }
+
+    return 0; // success
+
+rollback_dev_register:
+    return ret;
+}
+
+
+static void bbgpio_device_exit(int n)
+{
+    // free the RTDM device
+    rtdm_dev_unregister(&_bbgpio_devices[n]);
+}
+
+int __init bbgpio_init(void)
+{
+    u16 i;
+    s16 ret;
+
+    // initialize all the defined RTDM GPIO devices
+    for (i = 0; i < ARRAY_SIZE(_bbgpio_data); i++) {
+        ret = bbgpio_device_init(i);
+        if (ret < 0) {
+            return -1;
+        }
+    }
+
+    rtdm_printk(KERN_INFO "BBGPIO initialized\n");
+
+    return 0; // success
+}
+
+void __exit bbgpio_exit(void)
+{
+    u16 i;
+
+    // remove all the defined RTDM GPIO devices
+    for (i = 0; i < ARRAY_SIZE(_bbgpio_devices); i++) {
+        bbgpio_device_exit(i);
+    }
+
+    rtdm_printk(KERN_INFO "BBGPIO exit\n");
+}
+
+module_init(bbgpio_init);
+module_exit(bbgpio_exit);
+
+MODULE_AUTHOR("Øyvind Netland <oyvind@netland.name>");
+MODULE_DESCRIPTION("RTDM GPIO module for Beaglebone");
+MODULE_LICENSE("GPL");
diff --git a/drivers/xenomai/beaglebone/bbgpio.h b/drivers/xenomai/beaglebone/bbgpio.h
new file mode 100644
index 0000000..9782eb5
--- /dev/null
+++ b/drivers/xenomai/beaglebone/bbgpio.h
@@ -0,0 +1,36 @@
+#ifndef BBGPIO_H_
+#define BBGPIO_H_
+
+#include <rtdm/rtdm.h>
+
+//! code indicating GPIO input direction
+#define BBGPIO_DIR_IN             1
+//! code indicating GPIO output direction
+#define BBGPIO_DIR_OUT            2
+//! code indicating GPIO IRQ input direction
+#define BBGPIO_DIR_IRQ            3
+
+//! code indicating GPIO IRQ rising edge
+#define BBGPIO_IOCTL_EDGE_RISING        1
+//! code indicating GPIO IRQ falling edge
+#define BBGPIO_IOCTL_EDGE_FALLING       2
+//! code indicating GPIO IRQ both edges
+#define BBGPIO_IOCTL_EDGE_BOTH          3
+
+//! IOCTL code for getting GPIO direction
+#define BBGPIO_IOCTL_DIR_GET \
+    _IOR(RTDM_CLASS_EXPERIMENTAL, 0x01, int)
+//! IOCTL code for getting GPIO IRQ edge
+#define BBGPIO_IOCTL_EDGE_GET \
+    _IOR(RTDM_CLASS_EXPERIMENTAL, 0x02, int)
+//! IOCTL code for setting GPIO IRQ edge
+#define BBGPIO_IOCTL_EDGE_SET \
+    _IOW(RTDM_CLASS_EXPERIMENTAL, 0x03, int)
+//! IOCTL code for getting GPIO IRQ timeout in nanoseconds
+#define BBGPIO_IOCTL_TIMEOUT_GET \
+    _IOR(RTDM_CLASS_EXPERIMENTAL, 0x04, int)
+//! IOCTL code for setting GPIO IRQ timeout in nanoseconds
+#define BBGPIO_IOCTL_TIMEOUT_SET \
+    _IOW(RTDM_CLASS_EXPERIMENTAL, 0x05, int)
+
+#endif /* BBGPIO_H_ */
diff --git a/drivers/xenomai/beaglebone/bbpwm.c b/drivers/xenomai/beaglebone/bbpwm.c
new file mode 100755
index 0000000..c23d117
--- /dev/null
+++ b/drivers/xenomai/beaglebone/bbpwm.c
@@ -0,0 +1,332 @@
+#include "bbpwm.h"
+
+#include <linux/module.h>
+#include <linux/pwm.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+#include <rtdm/rtdm.h>
+#include <rtdm/driver.h>
+
+//! struct with data representing a PWM device.
+struct bbpwm_data {
+    //! PWM number for channel A
+    int pwma_n;
+    //! PWM number for channel B
+    int pwmb_n;
+    //! PWM device for channel A
+    struct pwm_device *pwma;
+    //! PWM device for channel B
+    struct pwm_device *pwmb;
+};
+
+/*!
+ * Method for handling an open action. The oflags define the period in milliseconds.
+ * If no oflags is set, then the default 1 millisecond period is chosen.
+ * @param fd rtdm file descriptor pointer
+ * @param oflags the value given when opening the file
+ * @return 0 on success, otherwise an error code
+ */
+static int bbpwm_open(struct rtdm_fd *fd, int oflags);
+/*!
+ * Method for handling a ioctl action.
+ * PERIOD GET return the period.
+ * DUTY GET return the % duty value of either channel A or B.
+ * DUTY NS GET return the nanosecond duty value for either channel A or B.
+ * DUTY SET set the % duty value of either channel A or B.
+ * DUTY NS SET set the nanosecond duty value for either channel A or B.
+ * @param fd rtdm file descriptor pointer
+ * @param request the ioctl request code
+ * @param arg pointer to input or output data
+ * @return 0 on success, otherwise an error code
+ */
+static int bbpwm_ioctl_rt(struct rtdm_fd *fd, unsigned int request, void *arg);
+/*!
+ * Method for handling a close action, which will disable the PWM device.
+ * @param fd rtdm file descriptor pointer
+ */
+static void bbpwm_close(struct rtdm_fd *fd);
+/*!
+ * Initialize a PWM device of the given number. Does not activate the PWM.
+ * @param n PWM number (in the list of this driver)
+ * @return 0 on success, otherwise an error code
+ */ 
+static int bbpwm_device_init(int n);
+/*
+ * Exit a PWM device of a given number.
+ * @param n PWM number (in the list of this driver)
+ */
+static void bbpwm_device_exit(int n);
+
+//! initialization of PWM data struct array, with all Beaglebone PWMs
+static struct bbpwm_data _bbpwm_data[3] = {
+    {
+        .pwma_n = 0,
+        .pwmb_n = 1,
+    },
+    {
+        .pwma_n = 2,
+        .pwmb_n = 3,
+    },
+    {
+        .pwma_n = 4,
+        .pwmb_n = 5,
+    },
+};
+
+//! the driver for the Beaglebone PWM RTDM driver
+static struct rtdm_driver _bbpwm_driver = {
+    .profile_info = RTDM_PROFILE_INFO("bbpwm", RTDM_CLASS_EXPERIMENTAL,
+            RTDM_SUBCLASS_GENERIC, 42),
+    .device_flags = RTDM_NAMED_DEVICE | RTDM_EXCLUSIVE,
+    .device_count = 3,
+    .context_size = sizeof(struct bbpwm_data),
+    .ops = {
+        .open = bbpwm_open,
+        .ioctl_rt = bbpwm_ioctl_rt,
+        .close = bbpwm_close,
+    },
+};
+
+//! initialization of PWM device struct array, with all Beaglebone PWMs
+static struct rtdm_device _bbpwm_devices[3] = {
+    {
+        .driver = &_bbpwm_driver,
+        .label = "pwm0_P9_31_29",
+    },
+    {
+        .driver = &_bbpwm_driver,
+        .label = "pwm1_P9_14_16",
+    },
+    {
+        .driver = &_bbpwm_driver,
+        .label = "pwm2_P8_19_13",
+    },
+};
+
+static int bbpwm_open(struct rtdm_fd *fd, int oflags)
+{
+    long period = 1000000;
+    struct rtdm_dev_context *context;
+    struct bbpwm_data *data;
+
+    if (oflags != 0) {
+        period = 1000000*oflags;
+    }
+
+    context = rtdm_fd_to_context(fd);
+    data = (struct bbpwm_data*)context->device->device_data;
+
+    // configure PWM A channel
+    pwm_config(data->pwma, 0, period);
+    pwm_enable(data->pwma);
+
+    // configure PWM B channel
+    pwm_config(data->pwmb, 0, period);
+    pwm_enable(data->pwmb);
+
+    return 0;
+}
+
+static int bbpwm_ioctl_rt(struct rtdm_fd *fd, unsigned int request, void *arg)
+{
+    int ret;
+    struct rtdm_dev_context *context;
+    struct bbpwm_data *data;
+    int int_tmp;
+    int period_tmp;
+
+    context = rtdm_fd_to_context(fd);
+    data = (struct bbpwm_data*)context->device->device_data;
+
+    switch (request) {
+    case BBPWM_IOCTL_PERIOD_GET:
+        // return the period of the PWM device, which is same for both channels
+        int_tmp = pwm_get_period(data->pwma);
+        return rtdm_safe_copy_to_user(fd, arg, &int_tmp, sizeof(int_tmp));
+
+    case BBPWM_IOCTL_DUTYA_GET:
+        // return the % duty value of channel A
+        int_tmp = (100*pwm_get_duty_cycle(data->pwma)) / pwm_get_period(data->pwma);
+        return rtdm_safe_copy_to_user(fd, arg, &int_tmp, sizeof(int_tmp));
+
+    case BBPWM_IOCTL_DUTYA_NS_GET:
+        // return the nanosecond duty value of channel A
+        int_tmp = pwm_get_duty_cycle(data->pwma);
+        return rtdm_safe_copy_to_user(fd, arg, &int_tmp, sizeof(int_tmp));
+
+    case BBPWM_IOCTL_DUTYB_GET:
+        // return the % duty value of channel B
+        int_tmp = (100*pwm_get_duty_cycle(data->pwmb)) / pwm_get_period(data->pwmb);
+        return rtdm_safe_copy_to_user(fd, arg, &int_tmp, sizeof(int_tmp));
+
+    case BBPWM_IOCTL_DUTYB_NS_GET:
+        // return the nanosecond duty value of channel B
+        int_tmp = pwm_get_duty_cycle(data->pwmb);
+        return rtdm_safe_copy_to_user(fd, arg, &int_tmp, sizeof(int_tmp));
+
+    case BBPWM_IOCTL_DUTYA_SET:
+        // read command value from user space
+        ret = rtdm_safe_copy_from_user(fd, &int_tmp, arg, sizeof(int_tmp));
+        if (ret < 0) {
+            return ret;
+        }
+
+        // get current period
+        period_tmp = pwm_get_period(data->pwma);
+        if (period_tmp <= 0) {
+            return -1;
+        }
+
+        // set the % duty value of channel A
+        ret = pwm_config(data->pwma, (int_tmp*period_tmp)/100, period_tmp);
+        return ret;
+
+    case BBPWM_IOCTL_DUTYA_NS_SET:
+        // read command value from user space
+        ret = rtdm_safe_copy_from_user(fd, &int_tmp, arg, sizeof(int_tmp));
+        if (ret < 0) {
+            return ret;
+        }
+
+        // get current period
+        period_tmp = pwm_get_period(data->pwma);
+        if (period_tmp <= 0) {
+            return -1;
+        }
+
+        // set the nanosecond duty value of channel A
+        ret = pwm_config(data->pwma, int_tmp, period_tmp);
+        return ret;
+
+    case BBPWM_IOCTL_DUTYB_SET:
+        // read command value from user space
+        ret = rtdm_safe_copy_from_user(fd, &int_tmp, arg, sizeof(int_tmp));
+        if (ret < 0) {
+            return ret;
+        }
+
+        // get current period
+        period_tmp = pwm_get_period(data->pwma);
+        if (period_tmp <= 0) {
+            return -1;
+        }
+
+        // set the % duty value of channel B
+        ret = pwm_config(data->pwmb, (int_tmp*period_tmp)/100, period_tmp);
+        return ret;
+
+    case BBPWM_IOCTL_DUTYB_NS_SET:
+        // read command value from user space
+        ret = rtdm_safe_copy_from_user(fd, &int_tmp, arg, sizeof(int_tmp));
+        if (ret < 0) {
+            return ret;
+        }
+
+        // get current period
+        period_tmp = pwm_get_period(data->pwma);
+        if (period_tmp <= 0) {
+            return -1;
+        }
+
+        // set the nanosecond duty value of channel B
+        ret = pwm_config(data->pwmb, int_tmp, period_tmp);
+        return ret;
+    }
+
+    return -1;
+}
+
+static void bbpwm_close(struct rtdm_fd *fd)
+{
+    struct rtdm_dev_context *context;
+    struct bbpwm_data *data;
+
+    // free PWM
+    context = rtdm_fd_to_context(fd);
+    data = (struct bbpwm_data*)context->device->device_data;
+
+    pwm_disable(data->pwma);
+    pwm_disable(data->pwmb);
+}
+
+static int bbpwm_device_init(int n)
+{
+    int ret;
+
+    // register the RTDM device
+    _bbpwm_devices[n].device_data = &_bbpwm_data[n];
+    ret = rtdm_dev_register(&_bbpwm_devices[n]);
+    if (ret < 0) {
+        rtdm_printk(KERN_ERR "RTPWM ERROR initialize %i\n", n);
+        goto rollback_dev_register;
+    }
+
+    // request PWM channel A
+    _bbpwm_data[n].pwma = pwm_request(_bbpwm_data[n].pwma_n, "PWM A");
+    if (_bbpwm_data[n].pwma == NULL) {
+        rtdm_printk(KERN_ERR "RTPWM ERROR initialize PWM%iA\n", n);
+        goto rollback_pwma;
+    }
+
+    // request PWM channel B
+    _bbpwm_data[n].pwmb = pwm_request(_bbpwm_data[n].pwmb_n, "PWM B");
+    if (_bbpwm_data[n].pwmb == NULL) {
+        rtdm_printk(KERN_ERR "RTPWM ERROR initialize PWM%iB\n", n);
+        goto rollback_pwmb;
+    }
+
+    return 0; // success
+
+rollback_pwmb:
+    pwm_free(_bbpwm_data[n].pwma);
+rollback_pwma:
+    rtdm_dev_unregister(&_bbpwm_devices[n]);
+rollback_dev_register:
+    return ret;
+}
+
+static void bbpwm_device_exit(int n)
+{
+    // free the RTDM device and PWM channels
+    pwm_free(_bbpwm_data[n].pwma);
+    pwm_free(_bbpwm_data[n].pwmb);
+    rtdm_dev_unregister(&_bbpwm_devices[n]);
+}
+
+int __init bbpwm_init(void)
+{
+    u16 i;
+    s16 ret;
+
+    // initialize all the defined RTDM PWM devices
+    for (i = 0; i < ARRAY_SIZE(_bbpwm_devices); i++) {
+        ret = bbpwm_device_init(i);
+        if (ret < 0) {
+            return -1;
+        }
+    }
+
+    rtdm_printk(KERN_INFO "BBPWM initialized\n");
+
+    return 0; // success
+}
+
+void __exit bbpwm_exit(void)
+{
+    u16 i;
+
+    // remove all the defined RTDM PWM devices
+    for (i = 0; i < ARRAY_SIZE(_bbpwm_devices); i++) {
+        bbpwm_device_exit(i);
+    }
+
+    rtdm_printk(KERN_INFO "BBPWM exit\n");
+}
+
+module_init(bbpwm_init);
+module_exit(bbpwm_exit);
+
+MODULE_AUTHOR("Øyvind Netland <oyvind@netland.name>");
+MODULE_DESCRIPTION("RTDM PWM module for Beaglebone");
+MODULE_LICENSE("GPL");
diff --git a/drivers/xenomai/beaglebone/bbpwm.h b/drivers/xenomai/beaglebone/bbpwm.h
new file mode 100644
index 0000000..7503a63
--- /dev/null
+++ b/drivers/xenomai/beaglebone/bbpwm.h
@@ -0,0 +1,34 @@
+#ifndef BBPWM_H_
+#define BBPWM_H_
+
+#include <rtdm/rtdm.h>
+
+//! IOCTL code for getting PWM period
+#define BBPWM_IOCTL_PERIOD_GET \
+    _IOR(RTDM_CLASS_EXPERIMENTAL, 0x11, int)
+//! IOCTL code for getting the % duty value of PWM channel A
+#define BBPWM_IOCTL_DUTYA_GET \
+    _IOR(RTDM_CLASS_EXPERIMENTAL, 0x12, int)
+//! IOCTL code for getting the nanosecond duty value of PWM channel A
+#define BBPWM_IOCTL_DUTYA_NS_GET \
+    _IOR(RTDM_CLASS_EXPERIMENTAL, 0x13, int)
+//! IOCTL code for getting the % duty value of PWM channel B
+#define BBPWM_IOCTL_DUTYB_GET \
+    _IOR(RTDM_CLASS_EXPERIMENTAL, 0x14, int)
+//! IOCTL code for getting the nanosecond duty value of PWM channel B
+#define BBPWM_IOCTL_DUTYB_NS_GET \
+    _IOR(RTDM_CLASS_EXPERIMENTAL, 0x15, int)
+//! IOCTL code for setting the % duty value of PWM channel A
+#define BBPWM_IOCTL_DUTYA_SET \
+    _IOW(RTDM_CLASS_EXPERIMENTAL, 0x16, int)
+//! IOCTL code for setting the nanosecond duty value of PWM channel A
+#define BBPWM_IOCTL_DUTYA_NS_SET \
+    _IOW(RTDM_CLASS_EXPERIMENTAL, 0x17, int)
+//! IOCTL code for setting the % duty value of PWM channel B
+#define BBPWM_IOCTL_DUTYB_SET \
+    _IOW(RTDM_CLASS_EXPERIMENTAL, 0x18, int)
+//! IOCTL code for setting the nanosecond duty value of PWM channel B
+#define BBPWM_IOCTL_DUTYB_NS_SET \
+    _IOW(RTDM_CLASS_EXPERIMENTAL, 0x19, int)
+
+#endif /* BBPWM_H_ */
-- 
2.7.4

